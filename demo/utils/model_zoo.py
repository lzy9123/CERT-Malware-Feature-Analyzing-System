#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jun 2 21:30:02 2019
@author: zhiyuli


Modified on Wed Jul 3 21:42:39 2019
Modified code style
@author: zhiyuli
"""

from sklearn import svm, datasets
from sklearn.cluster import KMeans
from sklearn.tree import DecisionTreeClassifier
import datetime
import numpy as np
from sklearn import linear_model
from joblib import dump, load
from sklearn.neural_network import MLPClassifier



class Models():
    """The interface of models

    The system supports multiple machine learning models to do 
    different data analyzing works. All models need to extend 
    the abstract class Model (Model.py) in order to fit into the Pipeline.
    """
    def __init__(self, name, verbose = True):
        """Initialization

            Substantialize the model

            Args:
                name: model name
                modelType: the type of model
                verbose: verbose mode to show the processing signals
        """

        self.name = name
        self.verbose = verbose

        self.modelType = None

    def _fit(self, x_train, y_train):
        """Initialization

            internal fitting only for sklearn model
            
            Args:
                x_train: training variables
                y_train: labels (can be none for 
                    Non-supervised learning)
        """
        
        # type checking
        if type(x_train).__name__ not in ("DataFrame", "Series", "ndarray") \
            or type(y_train).__name__ not in ("DataFrame", "Series", "ndarray", "NoneType"):
            raise TypeError("Fit function should take 'DataFrame' as input and "
                                "'x_train' (type %s) or 'y_train' (type %s) doesn't " %
                                (type(x_train), type(y_train)))

        # the shape of input data should be in shape of (N, M)
        # N would be sample size and M would be feature size
        if type(x_train).__name__ is "Series":
            x_train = np.array(x_train).reshape(-1,1)
        if type(x_train).__name__ is "ndarray" and len(x_train.shape) == 1: 
            x_train = x_train.reshape(-1,1) 

        if self.verbose:
            print('Start training ' + self.name + '\n')
            start = datetime.datetime.now()

        self.model = self.modelType.fit(x_train, y_train)

        if self.verbose:
            end = datetime.datetime.now()
            print(self.name + ' training time is ' + str(end - start))

    def load(self, load_path):
        """load Model
            
            load model from load path

            Args:
                load_path: path of load 

        """
        # type checking
        if type(load_path).__name__ != 'str':
            raise TypeError("_load function should take 'str' as input and "
                    "'load_path' (type %s) is not" % 
                    (type(load_path)))
        if self.verbose:
            print("load " + self.name + " from " + load_path)
        self.model = load(load_path)
        if self.verbose:
            print("load done")

    def save(self, path = None):
        """save Model
            
            save model to path

            Args:
                path: path to save

        """

        if path is None:
            if self.verbose:
                print("save to " + self.name + ".plt")

            dump(self.model, self.name + ".plt")

            if self.verbose:
                print("save done.")
        else:
            if self.verbose:
                print("save to " + path)

            dump(self.model, path) 

            if self.verbose:
                print("save done.")

    def fit(self, x_train, y_train, **parameter):
        """Interface API to be substantialized in real model

            Args:
                x_train: training variables
                y_train: labels (can be none for 
                    Non-supervised learning)
        """
        pass

    def predictP(self, input):
        """ predictP
            
            predict probability

            Args:
                input: the variables

            return
                predicted probabilities
        """

        if type(input).__name__ not in ("DataFrame", "Series", "ndarray"):
            raise TypeError("predictP function should take 'DataFrame' as input and "
                                "'input' (type %s) dosen't" %
                                (type(input)))

        if isinstance(input, list):
            input = np.array(input)
        if type(input).__name__ == "ndarray" and len(input.shape) == 1: 
            input = input.reshape(-1, 1)

        try:
            result = self.model.predict_proba(input)
        except:
            raise TypeError("Such model does not support prediction with probabilites.")

        result = result.reshape(len(input), -1)
        return result

    def predict(self, input):
        """ predict

            predict the result in values
            
            Args:
                input: the variables

            return
                predicted values
        """
        if type(input).__name__ not in ("DataFrame", "Series", "ndarray"):
            raise TypeError("predict function should take 'DataFrame' as input and "
                                "'input' (type %s) dosen't" %
                                (type(input)))
        if isinstance(input, list):
            input = np.array(input)
        if type(input).__name__ == "ndarray" and len(input.shape) == 1: 
            input = input.reshape(-1, 1)

        result = self.model.predict(input)
        result = result.reshape(len(input), -1)
        return result

    def top_probality(self, input, top_num):
        """ top_probality
            
            get top probable samples

            Args:
                input: the variables
                top_num: the number to select

            return 
                the index of samples
        """
        if type(top_num).__name__ != 'int':
            raise TypeError("top_probality take 'int' as top_num input and "
                            "'top_num' (type %s) dosen't" % (type(top_num)))

        predication_prob = self.model.predict_proba(input)[:, 1]
        index = np.argsort(predication_prob)[-top_num:][::-1]
        return index

    def __call__(self, input):
        """__call__
            
             special method triggered when 
             the instance of a class is called.

        """
        return self.predict(input)

    @property
    def __class__(self):
        """__class__
         
            get the class type of models 
            (used for pipeline step identification).

        """
        return Models

'''
@Override models
Decision Tree model
'''
class DecisionTree(Models):
    def fit(self, x_train, y_train, **parameter):
        self.modelType = DecisionTreeClassifier(**parameter)
        self._fit(x_train, y_train)

'''
@Override models
Logistic Regression model
'''
class LR(Models):
    def fit(self, x_train, y_train, **parameter):
        self.modelType = linear_model.LogisticRegression(**parameter)
        self._fit(x_train, y_train)

'''
@Override models
MLP model
'''
class MLP(Models):
    def fit(self, x_train, y_train, **parameter):
        self.modelType = MLPClassifier(**parameter)
        self._fit(x_train, y_train) 

'''
@Override models
MLP model
'''
class Kmeans(Models):
    def fit(self, x_train, y_train = None, **parameter):
        self.modelType = KMeans(**parameter)
        self._fit(x_train, None)        

'''
@Override models
Customized model with Keras Library
A example to extend with other library
'''
class Customized(Models):
    from keras.models import Sequential
    from keras.layers import Dense, Dropout
    model = Sequential()
    model.add(Dense(64, input_dim=2, activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(64, activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(1, activation='sigmoid'))
    def fit(self, x_train, y_train, batch_size = 32, loss = 'binary_crossentropy', optimizer='rmsprop', epochs = 5):
        self.model.compile(loss='binary_crossentropy',
              optimizer='rmsprop',
              metrics=['accuracy'])
        self.model.fit(x_train, y_train, epochs = epochs, batch_size = batch_size)
        self.modelType = self.model

