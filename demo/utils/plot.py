#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 1 03:57:49 2019
@author: zhiyuli
Debug


Modified on Mon Jul 15 21:42:39 2019
Debug
@author: zhiyuli
"""
import plotly.graph_objs as go
import plotly.offline
import plotly.figure_factory as ff
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
plotly.offline.init_notebook_mode(connected=True)

class plot:
    """plot
        In this class, the data will be plot

        Args:
            iplot_mode: True when used in jupyter-notebook
            

    """
    def __init__(self, iplot_mode = True):
        self.iplot_mode = iplot_mode
    
    def draw(self, y_data, x_data = None, mode = 'markers'):
        """draw
            draw the picture of x_data and y_data

            Args:
                x_data: data in the x_axis 
                    (if is none, then x_data would be set as 
                        index of y_data)
                y_data: data in the y_axis
        """

        # the predicted output of pipeline would be in shape of (sample_size, 1)
        # while plot class can only take 1-dimensional array as input
        # Therefore we would reshipe the array
        if (x_data is not None and len(x_data.shape) > 1 and x_data.shape[1] == 1):
            x_data = x_data.reshape(-1)

        if (len(y_data.shape) > 1 and y_data.shape[1] == 1):
            y_data = y_data.reshape(-1)

        if len(y_data.shape) == 1:
            if x_data is not None :
                trace0 = go.Scatter(x = x_data, y = y_data, mode = mode)
            else:
                x_data = np.arange(len(y_data))
                trace0 = go.Scatter(x = x_data, y = y_data, mode = mode)
        else:
            trace0 = go.Scatter(x = y_data[:,0], y = y_data[:,1], mode = mode) 
        fig = go.Figure([trace0])
        if self.iplot_mode:
            plotly.offline.iplot(fig)
        else:
            plotly.offline.plot(fig)


    def __call__(self, input):
        """__call__
            
             special method triggered when 
             the instance of a class is called.

             Args:
                input: data to be input

        """

        # the output of pipeline would be a tuple in forms of (y, x)
        if isinstance(input, tuple):
            self.draw(input[0], x_data = input[1])

        elif isinstance(input, np.ndarray):
            self.draw(input)

        # convert list into pipeline
        elif isinstance(input, list):
            input = np.array(list)
            self.draw(input)

        else:
            raise TypeError("tuple, array, list are allowed in Pipeline." 
                        "'input' (type %s) dosen't" %
                                (type(step)))

# some useful plot for pandas dataframe
def distribution(df, columns):
    """distribution

        plot the distplot picture with x: value, y: count
        Note can be extremely slow if the range of x is too large

        Args: 
            df: panda dataframe
            columns: list of columns name
    """
    fig = ff.create_distplot([df[c] for c in columns], columns)
    fig.show()

def correlations(df, columns, mode = 'cosine_similarity'):
    """correlations
        
        plot the heatmap with correlation/similarity between columns

        Args: 
            df: panda dataframe
            columns: list of columns name
    """
    if mode == 'cosine_similarity': 
        similarity_columns = cosine_similarity(df.values.T) 
        fig = go.Figure(data = [go.Heatmap(
        z = similarity_columns,
        x = columns,
        y = columns)])

    elif mode == 'correlation coefficient':
        corr_df = df[columns].corr() 
        fig = go.Figure(data = [go.Heatmap(
        z = corr_df.values,
        x = columns,
        y = columns)])
    fig.show()


def histogram_intersection(a, b):
    """hitogram_intersection

        Used for normalize in calculate correlation

        Args:
            a, b: data for correlation calculation
    """
    v = np.minimum(a, b).sum().round(decimals=1)
    return v



